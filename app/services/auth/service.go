package auth

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/followCode/djjs-event-reporting-backend/config"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

var (
	ErrUserNotFound         = errors.New("invalid credentials")
	ErrInvalidPassword      = errors.New("invalid credentials")
	ErrUserDisabled         = errors.New("account disabled")
	ErrEmailNotVerified     = errors.New("email not verified")
	ErrEmailAlreadyVerified = errors.New("email already verified")
	ErrInvalidToken         = errors.New("invalid token")
	ErrTokenExpired         = errors.New("token expired")
	ErrTokenUsed            = errors.New("token already used")
	ErrSessionNotFound      = errors.New("session not found")
	ErrSessionRevoked       = errors.New("session revoked")
	ErrSessionExpired       = errors.New("session expired")
)

type AuthService struct {
	mailer Mailer
}

func NewAuthService(mailer Mailer) *AuthService {
	return &AuthService{mailer: mailer}
}

// User represents a user for auth purposes
type User struct {
	ID              int64
	Email           string
	Name            string
	PasswordHash    string
	EmailVerifiedAt *time.Time
	DisabledAt      *time.Time
}

// Session represents a user session
type Session struct {
	ID               string
	UserID           int64
	UserAgent        string
	IP               string
	CreatedAt        time.Time
	LastUsedAt       time.Time
	ExpiresAt        time.Time
	IsCurrentSession bool
}

// Register creates a new user account (unverified)
func (s *AuthService) Register(ctx context.Context, email, password, name string, ip, userAgent string) error {
	// Hash password
	passwordHash, err := HashPassword(password)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// Check if user already exists
	var exists bool
	err = config.AuthDB.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", email).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check user existence: %w", err)
	}
	if exists {
		return ErrUserNotFound // Generic error - don't reveal if user exists
	}

	// Insert user
	var userID int64
	err = config.AuthDB.QueryRow(ctx,
		`INSERT INTO users (email, password, name, email_verified_at, created_on, updated_on)
		 VALUES ($1, $2, $3, NULL, NOW(), NOW())
		 RETURNING id`,
		email, passwordHash, name).Scan(&userID)
	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}

	// Generate verification token
	token, err := GenerateRandomToken(32)
	if err != nil {
		return fmt.Errorf("failed to generate token: %w", err)
	}

	tokenHash := HashToken(token)
	expiresAt := time.Now().Add(config.VerificationTTL)

	// Store verification token (ID will be auto-generated by database DEFAULT)
	tokenID := uuid.New().String()
	_, err = config.AuthDB.Exec(ctx,
		`INSERT INTO verification_tokens (id, user_id, token_hash, expires_at, created_at)
		 VALUES ($1, $2, $3, $4, NOW())`,
		tokenID, userID, tokenHash, expiresAt)
	if err != nil {
		return fmt.Errorf("failed to create verification token: %w", err)
	}

	// Send verification email
	if err := s.mailer.SendVerification(email, token); err != nil {
		// Log error but don't fail registration
		// In production, you might want to queue this
	}

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventRegister, &userID, ip, userAgent, nil)

	return nil
}

// VerifyEmail verifies a user's email address
func (s *AuthService) VerifyEmail(ctx context.Context, token string) error {
	tokenHash := HashToken(token)

	var userID int64
	var expiresAt time.Time
	var usedAt sql.NullTime

	err := config.AuthDB.QueryRow(ctx,
		`SELECT user_id, expires_at, used_at
		 FROM verification_tokens
		 WHERE token_hash = $1`,
		tokenHash).Scan(&userID, &expiresAt, &usedAt)

	if errors.Is(err, pgx.ErrNoRows) {
		return ErrInvalidToken
	}
	if err != nil {
		return fmt.Errorf("failed to query token: %w", err)
	}

	if usedAt.Valid {
		return ErrTokenUsed
	}

	if time.Now().After(expiresAt) {
		return ErrTokenExpired
	}

	// Update user as verified and mark token as used in a transaction
	tx, err := config.AuthDB.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	_, err = tx.Exec(ctx,
		`UPDATE users SET email_verified_at = NOW(), updated_on = NOW()
		 WHERE id = $1 AND email_verified_at IS NULL`,
		userID)
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}

	_, err = tx.Exec(ctx,
		`UPDATE verification_tokens SET used_at = NOW() WHERE token_hash = $1`,
		tokenHash)
	if err != nil {
		return fmt.Errorf("failed to mark token as used: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventEmailVerified, &userID, "", "", nil)

	return nil
}

// Login authenticates a user and creates a session
func (s *AuthService) Login(ctx context.Context, email, password, ip, userAgent string) (*User, string, string, error) {
	// Get user
	var user User
	err := config.AuthDB.QueryRow(ctx,
		`SELECT id, email, name, password, email_verified_at, disabled_at
		 FROM users
		 WHERE email = $1 AND is_deleted = false`,
		email).Scan(&user.ID, &user.Email, &user.Name, &user.PasswordHash,
		&user.EmailVerifiedAt, &user.DisabledAt)

	if errors.Is(err, pgx.ErrNoRows) {
		// Generic error - don't reveal if user exists
		_ = LogAuditEvent(ctx, AuditEventLoginFailed, nil, ip, userAgent, map[string]interface{}{"email": email})
		return nil, "", "", ErrUserNotFound
	}
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to query user: %w", err)
	}

	// Check if disabled
	if user.DisabledAt != nil {
		_ = LogAuditEvent(ctx, AuditEventLoginFailed, &user.ID, ip, userAgent, map[string]interface{}{"reason": "disabled"})
		return nil, "", "", ErrUserDisabled
	}

	// Verify password
	valid, err := VerifyPassword(password, user.PasswordHash)
	if err != nil {
		_ = LogAuditEvent(ctx, AuditEventLoginFailed, &user.ID, ip, userAgent, map[string]interface{}{"reason": "password_verify_error"})
		return nil, "", "", fmt.Errorf("failed to verify password: %w", err)
	}
	if !valid {
		_ = LogAuditEvent(ctx, AuditEventLoginFailed, &user.ID, ip, userAgent, map[string]interface{}{"reason": "invalid_password"})
		return nil, "", "", ErrInvalidPassword
	}

	// Check email verification if required
	if config.RequireEmailVerified && user.EmailVerifiedAt == nil {
		_ = LogAuditEvent(ctx, AuditEventLoginFailed, &user.ID, ip, userAgent, map[string]interface{}{"reason": "email_not_verified"})
		return nil, "", "", ErrEmailNotVerified
	}

	// Generate refresh token
	refreshToken, err := GenerateRandomToken(32) // 256 bits as hex
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	refreshTokenHash := HashRefreshToken(refreshToken)
	sessionID := uuid.New().String()
	expiresAt := time.Now().Add(config.RefreshTokenTTL)

	// Create session
	_, err = config.AuthDB.Exec(ctx,
		`INSERT INTO sessions (id, user_id, refresh_token_hash, user_agent, ip, created_at, last_used_at, expires_at)
		 VALUES ($1, $2, $3, $4, $5, NOW(), NOW(), $6)`,
		sessionID, user.ID, refreshTokenHash, userAgent, ip, expiresAt)
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to create session: %w", err)
	}

	// Generate access token
	accessToken, err := GenerateAccessToken(user.ID, sessionID)
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to generate access token: %w", err)
	}

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventLogin, &user.ID, ip, userAgent, map[string]interface{}{"session_id": sessionID})

	return &user, accessToken, refreshToken, nil
}

// RefreshToken refreshes an access token and rotates the refresh token
func (s *AuthService) RefreshToken(ctx context.Context, refreshToken string) (string, string, error) {
	refreshTokenHash := HashRefreshToken(refreshToken)

	var sessionID string
	var userID int64
	var expiresAt time.Time
	var revokedAt sql.NullTime

	err := config.AuthDB.QueryRow(ctx,
		`SELECT id, user_id, expires_at, revoked_at
		 FROM sessions
		 WHERE refresh_token_hash = $1`,
		refreshTokenHash).Scan(&sessionID, &userID, &expiresAt, &revokedAt)

	if errors.Is(err, pgx.ErrNoRows) {
		return "", "", ErrSessionNotFound
	}
	if err != nil {
		return "", "", fmt.Errorf("failed to query session: %w", err)
	}

	if revokedAt.Valid {
		return "", "", ErrSessionRevoked
	}

	if time.Now().After(expiresAt) {
		return "", "", ErrSessionExpired
	}

	// Generate new refresh token
	newRefreshToken, err := GenerateRandomToken(32)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate refresh token: %w", err)
	}

	newRefreshTokenHash := HashRefreshToken(newRefreshToken)

	// Atomic rotation: update session with new token hash
	// This ensures replay attacks fail (old token hash won't match after update)
	result, err := config.AuthDB.Exec(ctx,
		`UPDATE sessions
		 SET refresh_token_hash = $1, last_used_at = NOW()
		 WHERE id = $2 AND refresh_token_hash = $3 AND revoked_at IS NULL AND expires_at > NOW()`,
		newRefreshTokenHash, sessionID, refreshTokenHash)

	if err != nil {
		return "", "", fmt.Errorf("failed to rotate refresh token: %w", err)
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected != 1 {
		// Token was already rotated, expired, or revoked
		return "", "", ErrSessionNotFound
	}

	// Generate new access token
	accessToken, err := GenerateAccessToken(userID, sessionID)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate access token: %w", err)
	}

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventTokenRefreshed, &userID, "", "", map[string]interface{}{"session_id": sessionID})

	return accessToken, newRefreshToken, nil
}

// Logout revokes a session
func (s *AuthService) Logout(ctx context.Context, refreshToken string, userID int64) error {
	if refreshToken == "" {
		return nil // No session to revoke
	}

	refreshTokenHash := HashRefreshToken(refreshToken)

	// Revoke session (must belong to user)
	result, err := config.AuthDB.Exec(ctx,
		`UPDATE sessions
		 SET revoked_at = NOW()
		 WHERE refresh_token_hash = $1 AND user_id = $2 AND revoked_at IS NULL`,
		refreshTokenHash, userID)

	if err != nil {
		return fmt.Errorf("failed to revoke session: %w", err)
	}

	if result.RowsAffected() > 0 {
		_ = LogAuditEvent(ctx, AuditEventLogout, &userID, "", "", nil)
	}

	return nil
}

// ForgotPassword initiates a password reset flow
func (s *AuthService) ForgotPassword(ctx context.Context, email, ip, userAgent string) error {
	// Get user (only if verified)
	var userID int64
	var emailVerified sql.NullTime
	err := config.AuthDB.QueryRow(ctx,
		`SELECT id, email_verified_at
		 FROM users
		 WHERE email = $1 AND is_deleted = false`,
		email).Scan(&userID, &emailVerified)

	// Always return 200 to avoid email enumeration
	if errors.Is(err, pgx.ErrNoRows) || !emailVerified.Valid {
		return nil // Don't reveal if user exists
	}
	if err != nil {
		return fmt.Errorf("failed to query user: %w", err)
	}

	// Generate reset token
	token, err := GenerateRandomToken(32)
	if err != nil {
		return fmt.Errorf("failed to generate token: %w", err)
	}

	tokenHash := HashToken(token)
	expiresAt := time.Now().Add(config.PasswordResetTTL)

	// Store reset token (ID will be auto-generated by database DEFAULT)
	tokenID := uuid.New().String()
	_, err = config.AuthDB.Exec(ctx,
		`INSERT INTO password_reset_tokens (id, user_id, token_hash, expires_at, created_at)
		 VALUES ($1, $2, $3, $4, NOW())`,
		tokenID, userID, tokenHash, expiresAt)
	if err != nil {
		return fmt.Errorf("failed to create reset token: %w", err)
	}

	// Send reset email
	if err := s.mailer.SendPasswordReset(email, token); err != nil {
		// Log but don't fail
	}

	return nil
}

// ResetPassword resets a user's password using a reset token
func (s *AuthService) ResetPassword(ctx context.Context, token, newPassword string) error {
	tokenHash := HashToken(token)

	var userID int64
	var expiresAt time.Time
	var usedAt sql.NullTime

	err := config.AuthDB.QueryRow(ctx,
		`SELECT user_id, expires_at, used_at
		 FROM password_reset_tokens
		 WHERE token_hash = $1`,
		tokenHash).Scan(&userID, &expiresAt, &usedAt)

	if errors.Is(err, pgx.ErrNoRows) {
		return ErrInvalidToken
	}
	if err != nil {
		return fmt.Errorf("failed to query token: %w", err)
	}

	if usedAt.Valid {
		return ErrTokenUsed
	}

	if time.Now().After(expiresAt) {
		return ErrTokenExpired
	}

	// Hash new password
	passwordHash, err := HashPassword(newPassword)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// Update password, mark token as used, and revoke all sessions in a transaction
	tx, err := config.AuthDB.Begin(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback(ctx)

	// Update password
	_, err = tx.Exec(ctx,
		`UPDATE users SET password = $1, updated_on = NOW() WHERE id = $2`,
		passwordHash, userID)
	if err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	// Mark token as used
	_, err = tx.Exec(ctx,
		`UPDATE password_reset_tokens SET used_at = NOW() WHERE token_hash = $1`,
		tokenHash)
	if err != nil {
		return fmt.Errorf("failed to mark token as used: %w", err)
	}

	// Revoke all sessions for user
	_, err = tx.Exec(ctx,
		`UPDATE sessions SET revoked_at = NOW() WHERE user_id = $1 AND revoked_at IS NULL`,
		userID)
	if err != nil {
		return fmt.Errorf("failed to revoke sessions: %w", err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventPasswordReset, &userID, "", "", nil)

	return nil
}

// ChangePassword changes a user's password (requires current password)
func (s *AuthService) ChangePassword(ctx context.Context, userID int64, currentPassword, newPassword string) error {
	// Get user
	var passwordHash string
	err := config.AuthDB.QueryRow(ctx,
		`SELECT password FROM users WHERE id = $1 AND is_deleted = false`,
		userID).Scan(&passwordHash)

	if errors.Is(err, pgx.ErrNoRows) {
		return ErrUserNotFound
	}
	if err != nil {
		return fmt.Errorf("failed to query user: %w", err)
	}

	// Verify current password
	valid, err := VerifyPassword(currentPassword, passwordHash)
	if err != nil {
		return fmt.Errorf("failed to verify password: %w", err)
	}
	if !valid {
		return ErrInvalidPassword
	}

	// Hash new password
	newPasswordHash, err := HashPassword(newPassword)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// Update password
	_, err = config.AuthDB.Exec(ctx,
		`UPDATE users SET password = $1, updated_on = NOW() WHERE id = $2`,
		newPasswordHash, userID)
	if err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	// Optionally revoke all other sessions (keeping current)
	// Uncomment if desired:
	// _, err = config.AuthDB.Exec(ctx,
	// 	`UPDATE sessions SET revoked_at = NOW() WHERE user_id = $1 AND id != $2 AND revoked_at IS NULL`,
	// 	userID, sessionID)

	// Log audit event
	_ = LogAuditEvent(ctx, AuditEventPasswordChanged, &userID, "", "", nil)

	return nil
}

// GetSessions returns all active sessions for a user
func (s *AuthService) GetSessions(ctx context.Context, userID int64, currentSessionID string) ([]Session, error) {
	rows, err := config.AuthDB.Query(ctx,
		`SELECT id, user_id, user_agent, ip, created_at, last_used_at, expires_at
		 FROM sessions
		 WHERE user_id = $1 AND revoked_at IS NULL AND expires_at > NOW()
		 ORDER BY created_at DESC`,
		userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query sessions: %w", err)
	}
	defer rows.Close()

	var sessions []Session
	for rows.Next() {
		var session Session
		err := rows.Scan(&session.ID, &session.UserID, &session.UserAgent, &session.IP,
			&session.CreatedAt, &session.LastUsedAt, &session.ExpiresAt)
		if err != nil {
			return nil, fmt.Errorf("failed to scan session: %w", err)
		}
		session.IsCurrentSession = session.ID == currentSessionID
		sessions = append(sessions, session)
	}

	return sessions, nil
}

// RevokeSession revokes a specific session
func (s *AuthService) RevokeSession(ctx context.Context, userID int64, targetSessionID string) error {
	// Ensure session belongs to user
	result, err := config.AuthDB.Exec(ctx,
		`UPDATE sessions
		 SET revoked_at = NOW()
		 WHERE id = $1 AND user_id = $2 AND revoked_at IS NULL`,
		targetSessionID, userID)

	if err != nil {
		return fmt.Errorf("failed to revoke session: %w", err)
	}

	if result.RowsAffected() > 0 {
		_ = LogAuditEvent(ctx, AuditEventSessionRevoked, &userID, "", "", map[string]interface{}{"revoked_session_id": targetSessionID})
	}

	return nil
}


