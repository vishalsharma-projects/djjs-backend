// @title DJJS Event Reporting API
// @version 1.0
// @description API documentation for the DJJS Event Reporting Backend.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email vaish@gmail.com

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization

// @BasePath /
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/followCode/djjs-event-reporting-backend/app/api"
	"github.com/followCode/djjs-event-reporting-backend/app/middleware"
	"github.com/followCode/djjs-event-reporting-backend/app/models"
	"github.com/followCode/djjs-event-reporting-backend/app/services"
	"github.com/followCode/djjs-event-reporting-backend/config"
	"github.com/followCode/djjs-event-reporting-backend/docs"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"

	swaggerFiles "github.com/swaggo/files"     // swagger embed files
	ginSwagger "github.com/swaggo/gin-swagger" // gin-swagger middleware

	_ "github.com/followCode/djjs-event-reporting-backend/docs" // docs is generated by Swag CLI
)

func main() {
	// Load environment variables from .env file
	// Try multiple locations to find .env file
	wd, _ := os.Getwd()
	envPaths := []string{
		".env",                              // Current directory
		filepath.Join(wd, ".env"),          // Absolute path from working directory
		filepath.Join("..", "..", ".env"),  // Two levels up (if running from app/main/)
	}
	
	var loaded bool
	for _, envPath := range envPaths {
		if err := godotenv.Load(envPath); err == nil {
			log.Printf("Loaded .env file from: %s", envPath)
			loaded = true
			break
		} else {
			// Debug: log the error for troubleshooting
			log.Printf("Failed to load .env from %s: %v", envPath, err)
		}
	}
	
	if !loaded {
		log.Printf("Warning: .env file not found in any of these locations: %v", envPaths)
		log.Printf("Current working directory: %s", wd)
		log.Println("Continuing with system environment variables...")
	}

	// 1️⃣ Connect to Postgres (legacy GORM connection for existing routes)
	config.ConnectDB()

	// 1️⃣b Initialize new auth system config (pgx + Redis)
	if err := config.LoadAuthConfig(); err != nil {
		log.Fatalf("Failed to load auth config: %v", err)
	}

	// 2️⃣ Set JWT secret from environment (legacy - also set in internal config)
	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		log.Fatal("JWT_SECRET is missing in .env")
	}
	config.JWTSecret = []byte(jwtSecret)

	// 3️⃣ Initialize S3 (fail fast if S3 is not properly configured)
	if err := services.InitializeS3(); err != nil {
		log.Printf("═══════════════════════════════════════════════════════════════")
		log.Printf("ERROR: Failed to initialize S3: %v", err)
		log.Printf("ERROR: S3 is required for file uploads and media access")
		log.Printf("ERROR: Please check your .env file for:")
		log.Printf("ERROR:   - AWS_ACCESS_KEY_ID")
		log.Printf("ERROR:   - AWS_SECRET_ACCESS_KEY")
		log.Printf("ERROR:   - AWS_S3_BUCKET_NAME")
		log.Printf("ERROR:   - AWS_REGION")
		log.Printf("ERROR: And verify IAM permissions: s3:ListBucket, s3:GetObject, s3:PutObject, s3:DeleteObject")
		log.Printf("═══════════════════════════════════════════════════════════════")
		// In production, you might want to fail fast: log.Fatalf(...)
		// For now, log error but continue (some features may not work)
	}

	// 3️⃣b Startup invariant check: verify no legacy records with NULL s3_key
	checkLegacyRecords()

	// 3️⃣c Start draft cleanup scheduler (runs daily to delete drafts older than 10 days)
	// Get cleanup hour from environment (default: 2 AM)
	cleanupHour := 2 // Default to 2 AM
	if cleanupHourStr := os.Getenv("DRAFT_CLEANUP_HOUR"); cleanupHourStr != "" {
		if parsedHour, err := strconv.Atoi(cleanupHourStr); err == nil && parsedHour >= 0 && parsedHour <= 23 {
			cleanupHour = parsedHour
		}
	}
	daysOld := 10 // Delete drafts older than 10 days
	if daysOldStr := os.Getenv("DRAFT_CLEANUP_DAYS"); daysOldStr != "" {
		if parsedDays, err := strconv.Atoi(daysOldStr); err == nil && parsedDays > 0 {
			daysOld = parsedDays
		}
	}
	services.StartDraftCleanupScheduler(cleanupHour, daysOld)

	// 4️⃣ Create Gin router
	r := gin.New()
	
	// Configure trusted proxies for production (prevents the warning)
	// In production, set this to your reverse proxy IPs (e.g., nginx, load balancer)
	// For development, we can trust localhost proxies
	if gin.Mode() == gin.ReleaseMode {
		// In production, only trust specific proxies
		// Example: r.SetTrustedProxies([]string{"127.0.0.1", "::1"})
		// For now, we'll trust localhost only
		r.SetTrustedProxies([]string{"127.0.0.1", "::1"})
	} else {
		// In development, trust localhost proxies
		r.SetTrustedProxies([]string{"127.0.0.1", "::1"})
	}
	
	// Add recovery middleware (gin.Default includes this, but we want to control it)
	r.Use(gin.Recovery())
	
	// Add logger middleware only in debug mode
	if gin.Mode() == gin.DebugMode {
		r.Use(gin.Logger())
	}

	// Add timeout middleware (30 seconds)
	r.Use(middleware.TimeoutMiddleware(30 * time.Second))

	// Enable CORS for Angular frontend
	// Get allowed origins from environment - REQUIRED in production
	allowedOrigins := os.Getenv("ALLOWED_ORIGINS")
	if allowedOrigins == "" {
		if gin.Mode() == gin.DebugMode {
			// Only allow localhost in debug mode
			allowedOrigins = "http://localhost:4200,http://localhost:3000"
			log.Println("Warning: ALLOWED_ORIGINS not set, using localhost defaults (debug mode only)")
		} else {
			log.Fatal("ALLOWED_ORIGINS environment variable is required in production")
		}
	}
	
	origins := []string{}
	for _, origin := range strings.Split(allowedOrigins, ",") {
		origins = append(origins, strings.TrimSpace(origin))
	}
	
	r.Use(cors.New(cors.Config{
		AllowOrigins:     origins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Content-Length", "Accept-Encoding", "X-CSRF-Token", "Authorization", "accept", "origin", "Cache-Control", "X-Requested-With", "x-request-id", "X-Request-Id"},
		ExposeHeaders:    []string{"Content-Length", "Authorization"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	// Swagger documentation route - only enable if ENABLE_SWAGGER is set to "true"
	// In production, this should be disabled or protected
	if os.Getenv("ENABLE_SWAGGER") == "true" || gin.Mode() == gin.DebugMode {
		// Create a custom handler that intercepts doc.json requests
		swaggerHandler := func(c *gin.Context) {
			// Check if this is a request for doc.json
			if c.Request.URL.Path == "/swagger/doc.json" || strings.HasSuffix(c.Request.URL.Path, "/doc.json") {
				swaggerDoc := docs.SwaggerInfo.ReadDoc()
				
				// Parse the Swagger JSON
				var swaggerJSON map[string]interface{}
				if err := json.Unmarshal([]byte(swaggerDoc), &swaggerJSON); err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse swagger doc"})
					return
				}
				
				// Get API server URL from environment variable
				apiServerURL := os.Getenv("API_SERVER_URL")
				
				// If not set, determine from request (works for both dev and production)
				if apiServerURL == "" {
					host := c.Request.Host
					
					// Detect scheme: use http for localhost/127.0.0.1, https for production
					scheme := "https"
					isLocalhost := host == "localhost" || 
						strings.HasPrefix(host, "localhost:") ||
						host == "127.0.0.1" ||
						strings.HasPrefix(host, "127.0.0.1:")
					
					// Also check X-Forwarded-Proto header (for reverse proxies)
					forwardedProto := c.GetHeader("X-Forwarded-Proto")
					if forwardedProto == "http" {
						scheme = "http"
					} else if isLocalhost {
						// Localhost should always use http in dev
						scheme = "http"
					}
					
					apiServerURL = scheme + "://" + host
				}
				
				// Set the host and scheme dynamically for Swagger 2.0
				if apiServerURL != "" {
					if strings.HasPrefix(apiServerURL, "https://") {
						swaggerJSON["schemes"] = []string{"https"}
						host := strings.TrimPrefix(apiServerURL, "https://")
						swaggerJSON["host"] = host
					} else if strings.HasPrefix(apiServerURL, "http://") {
						swaggerJSON["schemes"] = []string{"http"}
						host := strings.TrimPrefix(apiServerURL, "http://")
						swaggerJSON["host"] = host
					} else {
						// Fallback: parse host and determine scheme
						host := apiServerURL
						if strings.Contains(host, "localhost") || strings.Contains(host, "127.0.0.1") {
							swaggerJSON["schemes"] = []string{"http"}
						} else {
							swaggerJSON["schemes"] = []string{"https"}
						}
						swaggerJSON["host"] = host
					}
				}
				
				c.JSON(http.StatusOK, swaggerJSON)
				return
			}
			
			// For all other requests, use the default Swagger handler
			ginSwagger.WrapHandler(swaggerFiles.Handler)(c)
		}
		
		r.GET("/swagger/*any", swaggerHandler)
	}

	// 5️⃣ Setup all API routes
	api.SetupRoutes(r)

	// 6️⃣ Protected route example
	r.GET("/protected", middleware.AuthRequired(), func(c *gin.Context) {
		userID, _ := c.Get("userID")
		roleID, _ := c.Get("roleID")
		c.JSON(200, gin.H{
			"message": "You are authorized",
			"userID":  userID,
			"roleID":  roleID,
		})
	})

	// 7️⃣ Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on port %s...", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatalf("Failed to run server: %v", err)
	}
}

// checkLegacyRecords performs startup invariant check for NULL s3_key records
// Logs ERROR and WARN loudly if legacy records exist
func checkLegacyRecords() {
	var eventMediaCount int64
	var branchMediaCount int64

	// Count EventMedia records with NULL s3_key
	if err := config.DB.Model(&models.EventMedia{}).
		Where("s3_key IS NULL OR s3_key = ''").
		Count(&eventMediaCount).Error; err != nil {
		log.Printf("WARNING: Failed to check event_media for NULL s3_key: %v", err)
	} else if eventMediaCount > 0 {
		log.Printf("═══════════════════════════════════════════════════════════════")
		log.Printf("ERROR: Found %d EventMedia records with NULL or empty s3_key", eventMediaCount)
		log.Printf("ERROR: These records will cause HTTP 500 errors when accessed")
		log.Printf("ERROR: Run migration: init/migrations/backfill_s3_key_from_file_url.sql")
		log.Printf("═══════════════════════════════════════════════════════════════")
	}

	// Count BranchMedia records with NULL s3_key
	if err := config.DB.Model(&models.BranchMedia{}).
		Where("s3_key IS NULL OR s3_key = ''").
		Count(&branchMediaCount).Error; err != nil {
		log.Printf("WARNING: Failed to check branch_media for NULL s3_key: %v", err)
	} else if branchMediaCount > 0 {
		log.Printf("═══════════════════════════════════════════════════════════════")
		log.Printf("ERROR: Found %d BranchMedia records with NULL or empty s3_key", branchMediaCount)
		log.Printf("ERROR: These records will cause HTTP 500 errors when accessed")
		log.Printf("ERROR: Run migration: init/migrations/add_branch_media_fields.sql")
		log.Printf("═══════════════════════════════════════════════════════════════")
	}

	if eventMediaCount == 0 && branchMediaCount == 0 {
		log.Println("✓ Startup check passed: All media records have s3_key populated")
	}
}

